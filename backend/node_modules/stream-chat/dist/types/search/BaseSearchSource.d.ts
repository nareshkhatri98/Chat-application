import { StateStore } from '../store';
import { type DebouncedFunc } from '../utils';
export type SearchSourceType = 'channels' | 'users' | 'messages' | (string & {});
export type QueryReturnValue<T> = {
    items: T[];
    next?: string | null;
};
export type DebounceOptions = {
    debounceMs: number;
};
type DebouncedExecQueryFunction = DebouncedFunc<(searchString?: string) => Promise<void>>;
export interface SearchSource<T = any> {
    activate(): void;
    cancelScheduledQuery(): void;
    canExecuteQuery(newSearchString?: string): boolean;
    deactivate(): void;
    readonly hasNext: boolean;
    readonly hasResults: boolean;
    readonly initialState: SearchSourceState<T>;
    readonly isActive: boolean;
    readonly isLoading: boolean;
    readonly items: T[] | undefined;
    readonly lastQueryError: Error | undefined;
    readonly next: string | undefined | null;
    readonly offset: number | undefined;
    resetState(): void;
    search(text?: string): Promise<void> | undefined;
    readonly searchQuery: string;
    setDebounceOptions(options: DebounceOptions): void;
    readonly state: StateStore<SearchSourceState<T>>;
    readonly type: SearchSourceType;
}
export type SearchSourceState<T = any> = {
    hasNext: boolean;
    isActive: boolean;
    isLoading: boolean;
    items: T[] | undefined;
    searchQuery: string;
    lastQueryError?: Error;
    next?: string | null;
    offset?: number;
};
export type SearchSourceOptions = {
    /** The number of milliseconds to debounce the search query. The default interval is 300ms. */
    debounceMs?: number;
    pageSize?: number;
};
export declare abstract class BaseSearchSource<T> implements SearchSource<T> {
    state: StateStore<SearchSourceState<T>>;
    protected pageSize: number;
    abstract readonly type: SearchSourceType;
    protected searchDebounced: DebouncedExecQueryFunction;
    protected constructor(options?: SearchSourceOptions);
    get lastQueryError(): Error | undefined;
    get hasNext(): boolean;
    get hasResults(): boolean;
    get isActive(): boolean;
    get isLoading(): boolean;
    get initialState(): {
        hasNext: boolean;
        isActive: boolean;
        isLoading: boolean;
        items: undefined;
        lastQueryError: undefined;
        next: undefined;
        offset: number;
        searchQuery: string;
    };
    get items(): T[] | undefined;
    get next(): string | null | undefined;
    get offset(): number | undefined;
    get searchQuery(): string;
    protected abstract query(searchQuery: string): Promise<QueryReturnValue<T>>;
    protected abstract filterQueryResults(items: T[]): T[] | Promise<T[]>;
    setDebounceOptions: ({ debounceMs }: DebounceOptions) => void;
    activate: () => void;
    deactivate: () => void;
    canExecuteQuery: (newSearchString?: string) => boolean;
    protected getStateBeforeFirstQuery(newSearchString: string): SearchSourceState<T>;
    protected getStateAfterQuery(stateUpdate: Partial<SearchSourceState<T>>, isFirstPage: boolean): SearchSourceState<T>;
    executeQuery(newSearchString?: string): Promise<void>;
    search: (searchQuery?: string) => Promise<void> | undefined;
    cancelScheduledQuery(): void;
    resetState(): void;
    resetStateAndActivate(): void;
}
export {};
